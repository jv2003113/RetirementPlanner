import type { Express, Request, Response } from "express";
import { createServer, type Server } from "http";
import passport from "passport";
import bcrypt from "bcrypt";
import { storage } from "./storage";
import {
  insertUserSchema,
  insertRetirementGoalSchema,
  insertInvestmentAccountSchema,
  insertAssetAllocationSchema,
  insertSecurityHoldingSchema,
  insertRetirementExpenseSchema,
  insertActivitySchema,
  insertRothConversionPlanSchema,
  insertRothConversionScenarioSchema,
  insertMultiStepFormProgressSchema,
  insertRetirementPlanSchema,
  insertAnnualSnapshotSchema,
  insertAccountBalanceSchema,
  insertMilestoneSchema,
  insertLiabilitySchema,
} from "../shared/schema";
import { z } from "zod";
import { generateRetirementPlan } from "./planGenerator";

// Middleware to check if user is authenticated
function requireAuth(req: Request, res: Response, next: any) {
  if (req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ message: "Authentication required" });
}

// Helper function to get current user from request
function getCurrentUser(req: Request): any {
  return req.user;
}

// Function to generate sample scenarios for a Roth conversion plan
async function generateSampleScenarios(plan: any) {
  const scenarios = [];
  const annualConversion = parseFloat(plan.conversionAmount) / plan.yearsToConvert;
  const currentTaxRate = parseFloat(plan.currentTaxRate) / 100;
  
  let traditionalBalance = parseFloat(plan.traditionalIraBalance);
  let rothBalance = 0;
  let totalTaxPaid = 0;
  
  // Generate scenarios for conversion years
  for (let year = 1; year <= plan.yearsToConvert; year++) {
    const age = plan.currentAge + year - 1;
    const taxCost = annualConversion * currentTaxRate;
    totalTaxPaid += taxCost;
    
    // Apply conversion
    traditionalBalance -= annualConversion;
    rothBalance += annualConversion - taxCost;
    
    // Apply growth to both accounts
    traditionalBalance *= (1 + parseFloat(plan.expectedReturn) / 100);
    rothBalance *= (1 + parseFloat(plan.expectedReturn) / 100);
    
    scenarios.push({
      planId: plan.id,
      year,
      age,
      conversionAmount: annualConversion.toString(),
      taxCost: taxCost.toString(),
      traditionalBalance: traditionalBalance.toString(),
      rothBalance: rothBalance.toString(),
      totalTaxPaid: totalTaxPaid.toString(),
      netWorth: (traditionalBalance + rothBalance).toString(),
    });
  }
  
  // Generate scenarios for years after conversion
  const yearsAfterConversion = plan.retirementAge - plan.currentAge - plan.yearsToConvert;
  for (let year = plan.yearsToConvert + 1; year <= plan.yearsToConvert + yearsAfterConversion; year++) {
    const age = plan.currentAge + year - 1;
    
    // Apply growth to both accounts
    traditionalBalance *= (1 + parseFloat(plan.expectedReturn) / 100);
    rothBalance *= (1 + parseFloat(plan.expectedReturn) / 100);
    
    scenarios.push({
      planId: plan.id,
      year,
      age,
      conversionAmount: "0",
      taxCost: "0",
      traditionalBalance: traditionalBalance.toString(),
      rothBalance: rothBalance.toString(),
      totalTaxPaid: totalTaxPaid.toString(),
      netWorth: (traditionalBalance + rothBalance).toString(),
    });
  }
  
  // Save the generated scenarios to the database
  const createdScenarios = [];
  for (const scenario of scenarios) {
    try {
      const createdScenario = await storage.createRothConversionScenario(scenario);
      createdScenarios.push(createdScenario);
    } catch (error) {
      console.error('Error creating scenario:', error);
    }
  }
  
  return createdScenarios;
}

export async function registerRoutes(app: Express): Promise<Server> {
  
  // Authentication routes
  app.post("/api/auth/signup", async (req: Request, res: Response) => {
    try {
      const { username, password, email, firstName, lastName } = req.body;
      
      // Validate required fields
      if (!username || !password) {
        return res.status(400).json({ message: "Username and password are required" });
      }
      
      // Check if user already exists
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ message: "Username already exists" });
      }
      
      // Hash password
      const saltRounds = 10;
      const hashedPassword = await bcrypt.hash(password, saltRounds);
      
      // Create user
      const userData = {
        username,
        password: hashedPassword,
        email,
        firstName,
        lastName,
      };
      
      const user = await storage.createUser(userData);
      
      // Log the user in automatically after signup
      req.login(user, (err) => {
        if (err) {
          console.error('Login error after signup:', err);
          return res.status(500).json({ message: "Account created but login failed" });
        }
        
        // Don't return password in response
        const { password: _, ...userWithoutPassword } = user;
        return res.status(201).json({ 
          message: "Account created successfully", 
          user: userWithoutPassword 
        });
      });
    } catch (error) {
      console.error('Signup error:', error);
      return res.status(500).json({ message: "Failed to create account" });
    }
  });

  app.post("/api/auth/login", (req: Request, res: Response, next) => {
    passport.authenticate('local', (err: any, user: any, info: any) => {
      if (err) {
        return res.status(500).json({ message: "Authentication error" });
      }
      if (!user) {
        return res.status(401).json({ message: info?.message || "Invalid credentials" });
      }
      req.login(user, (err) => {
        if (err) {
          return res.status(500).json({ message: "Login failed" });
        }
        return res.json({ message: "Login successful", user });
      });
    })(req, res, next);
  });

  app.post("/api/auth/logout", (req: Request, res: Response) => {
    req.logout((err) => {
      if (err) {
        return res.status(500).json({ message: "Logout failed" });
      }
      res.json({ message: "Logout successful" });
    });
  });

  app.get("/api/auth/me", (req: Request, res: Response) => {
    if (req.isAuthenticated()) {
      res.json({ user: req.user });
    } else {
      res.status(401).json({ message: "Not authenticated" });
    }
  });
  
  // User routes
  app.get("/api/users/:id", async (req: Request, res: Response) => {
    const userId = parseInt(req.params.id);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    const user = await storage.getUser(userId);
    
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    
    // Don't return password in response
    const { password, ...userWithoutPassword } = user;
    return res.json(userWithoutPassword);
  });

  app.post("/api/users", async (req: Request, res: Response) => {
    try {
      const userData = insertUserSchema.parse(req.body);
      const user = await storage.createUser(userData);
      
      // Don't return password in response
      const { password, ...userWithoutPassword } = user;
      return res.status(201).json(userWithoutPassword);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid user data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to create user" });
    }
  });

  app.patch("/api/users/:id", async (req: Request, res: Response) => {
    const userId = parseInt(req.params.id);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    try {
      const userData = insertUserSchema.partial().parse(req.body);
      const updatedUser = await storage.updateUser(userId, userData);
      
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Don't return password in response
      const { password, ...userWithoutPassword } = updatedUser;
      return res.json(userWithoutPassword);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid user data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to update user" });
    }
  });

  // Retirement goals routes
  app.get("/api/users/:userId/retirement-goals", async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    const goals = await storage.getRetirementGoals(userId);
    return res.json(goals);
  });

  app.post("/api/retirement-goals", async (req: Request, res: Response) => {
    try {
      const goalData = insertRetirementGoalSchema.parse(req.body);
      const goal = await storage.createRetirementGoal(goalData);
      
      // Create an activity for this goal creation
      await ({
        userId: goalData.userId,
        activityType: "goal_created",
        title: "New Retirement Goal",
        description: `Added a new retirement goal${goalData.description ? ': ' + goalData.description : ''}`,
        metadata: {
          goalId: goal.id,
          category: goalData.category,
          priority: goalData.priority
        }
      });
      
      return res.status(201).json(goal);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid goal data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to create retirement goal" });
    }
  });

  app.patch("/api/retirement-goals/:id", async (req: Request, res: Response) => {
    const goalId = parseInt(req.params.id);
    
    if (isNaN(goalId)) {
      return res.status(400).json({ message: "Invalid goal ID" });
    }
    
    try {
      const goalData = insertRetirementGoalSchema.partial().parse(req.body);
      const updatedGoal = await storage.updateRetirementGoal(goalId, goalData);
      
      if (!updatedGoal) {
        return res.status(404).json({ message: "Retirement goal not found" });
      }
      
      // Create an activity for this goal update
      await storage.createActivity({
        userId: updatedGoal.userId,
        activityType: "goal_updated",
        title: "Updated Retirement Goal",
        description: `Updated retirement goal${updatedGoal.description ? ': ' + updatedGoal.description : ''}`,
        metadata: {
          goalId: updatedGoal.id,
          category: updatedGoal.category,
          priority: updatedGoal.priority
        }
      });
      
      return res.json(updatedGoal);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid goal data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to update retirement goal" });
    }
  });

  app.delete("/api/retirement-goals/:id", async (req: Request, res: Response) => {
    const goalId = parseInt(req.params.id);
    
    if (isNaN(goalId)) {
      return res.status(400).json({ message: "Invalid goal ID" });
    }
    
    // Get the goal before deleting it to capture user info and goal details
    const goal = await storage.getRetirementGoal(goalId);
    if (!goal) {
      return res.status(404).json({ message: "Retirement goal not found" });
    }
    
    const success = await storage.deleteRetirementGoal(goalId);
    
    if (!success) {
      return res.status(404).json({ message: "Retirement goal not found" });
    }
    
    // Create an activity for this goal deletion
    await storage.createActivity({
      userId: goal.userId,
      activityType: "goal_deleted",
      title: "Deleted Retirement Goal",
      description: `Deleted retirement goal${goal.description ? ': ' + goal.description : ''}`,
      metadata: {
        goalId: goal.id,
        category: goal.category,
        priority: goal.priority
      }
    });
    
    return res.status(204).end();
  });

  // Investment accounts routes
  app.get("/api/users/:userId/investment-accounts", async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    const accounts = await storage.getInvestmentAccounts(userId);
    return res.json(accounts);
  });

  app.post("/api/investment-accounts", async (req: Request, res: Response) => {
    try {
      const accountData = insertInvestmentAccountSchema.parse(req.body);
      const account = await storage.createInvestmentAccount(accountData);
      return res.status(201).json(account);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid account data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to create investment account" });
    }
  });

  app.patch("/api/investment-accounts/:id", async (req: Request, res: Response) => {
    const accountId = parseInt(req.params.id);
    
    if (isNaN(accountId)) {
      return res.status(400).json({ message: "Invalid account ID" });
    }
    
    try {
      const accountData = insertInvestmentAccountSchema.partial().parse(req.body);
      const updatedAccount = await storage.updateInvestmentAccount(accountId, accountData);
      
      if (!updatedAccount) {
        return res.status(404).json({ message: "Investment account not found" });
      }
      
      return res.json(updatedAccount);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid account data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to update investment account" });
    }
  });

  app.delete("/api/investment-accounts/:id", async (req: Request, res: Response) => {
    const accountId = parseInt(req.params.id);
    
    if (isNaN(accountId)) {
      return res.status(400).json({ message: "Invalid account ID" });
    }
    
    const success = await storage.deleteInvestmentAccount(accountId);
    
    if (!success) {
      return res.status(404).json({ message: "Investment account not found" });
    }
    
    return res.status(204).end();
  });

  // Asset allocations routes
  app.get("/api/investment-accounts/:accountId/asset-allocations", async (req: Request, res: Response) => {
    const accountId = parseInt(req.params.accountId);
    
    if (isNaN(accountId)) {
      return res.status(400).json({ message: "Invalid account ID" });
    }
    
    const allocations = await storage.getAssetAllocations(accountId);
    return res.json(allocations);
  });

  app.post("/api/asset-allocations", async (req: Request, res: Response) => {
    try {
      const allocationData = insertAssetAllocationSchema.parse(req.body);
      const allocation = await storage.createAssetAllocation(allocationData);
      return res.status(201).json(allocation);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid allocation data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to create asset allocation" });
    }
  });

  app.patch("/api/asset-allocations/:id", async (req: Request, res: Response) => {
    const allocationId = parseInt(req.params.id);
    
    if (isNaN(allocationId)) {
      return res.status(400).json({ message: "Invalid allocation ID" });
    }
    
    try {
      const allocationData = insertAssetAllocationSchema.partial().parse(req.body);
      const updatedAllocation = await storage.updateAssetAllocation(allocationId, allocationData);
      
      if (!updatedAllocation) {
        return res.status(404).json({ message: "Asset allocation not found" });
      }
      
      return res.json(updatedAllocation);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid allocation data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to update asset allocation" });
    }
  });

  app.delete("/api/asset-allocations/:id", async (req: Request, res: Response) => {
    const allocationId = parseInt(req.params.id);
    
    if (isNaN(allocationId)) {
      return res.status(400).json({ message: "Invalid allocation ID" });
    }
    
    const success = await storage.deleteAssetAllocation(allocationId);
    
    if (!success) {
      return res.status(404).json({ message: "Asset allocation not found" });
    }
    
    return res.status(204).end();
  });

  // Security holdings routes
  app.get("/api/investment-accounts/:accountId/security-holdings", async (req: Request, res: Response) => {
    const accountId = parseInt(req.params.accountId);
    
    if (isNaN(accountId)) {
      return res.status(400).json({ message: "Invalid account ID" });
    }
    
    const holdings = await storage.getSecurityHoldings(accountId);
    return res.json(holdings);
  });

  app.post("/api/security-holdings", async (req: Request, res: Response) => {
    try {
      const holdingData = insertSecurityHoldingSchema.parse(req.body);
      const newHolding = await storage.createSecurityHolding(holdingData);
      
      // Create activity for adding a new security holding
      await storage.createActivity({
        userId: (await storage.getInvestmentAccount(holdingData.accountId))?.userId || 1,
        activityType: "portfolio_update",
        description: `Added ${holdingData.ticker} to portfolio`,
        date: new Date(),
        metadata: { ticker: holdingData.ticker, percentage: holdingData.percentage }
      });
      
      res.status(201).json(newHolding);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid holding data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to create security holding" });
    }
  });

  app.patch("/api/security-holdings/:id", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid security holding ID" });
      }
      
      const existingHolding = await storage.getSecurityHolding(id);
      
      if (!existingHolding) {
        return res.status(404).json({ message: "Security holding not found" });
      }
      
      const updateData = insertSecurityHoldingSchema.partial().parse(req.body);
      const updatedHolding = await storage.updateSecurityHolding(id, updateData);
      
      // Create activity for updating security holding
      await storage.createActivity({
        userId: (await storage.getInvestmentAccount(existingHolding.accountId))?.userId || 1,
        activityType: "portfolio_update",
        description: `Updated ${existingHolding.ticker} allocation`,
        date: new Date(),
        metadata: { 
          ticker: existingHolding.ticker, 
          oldPercentage: existingHolding.percentage,
          newPercentage: updateData.percentage || existingHolding.percentage
        }
      });
      
      res.json(updatedHolding);
    } catch (error: unknown) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid holding data", errors: error.errors });
      }
      return res.status(400).json({ message: error instanceof Error ? error.message : "Unknown error" });
    }
  });

  app.delete("/api/security-holdings/:id", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid security holding ID" });
      }
      
      const existingHolding = await storage.getSecurityHolding(id);
      
      if (!existingHolding) {
        return res.status(404).json({ message: "Security holding not found" });
      }
      
      const deleted = await storage.deleteSecurityHolding(id);
      
      // Create activity for deleting security holding
      await storage.createActivity({
        userId: (await storage.getInvestmentAccount(existingHolding.accountId))?.userId || 1,
        activityType: "portfolio_update",
        description: `Removed ${existingHolding.ticker} from portfolio`,
        date: new Date(),
        metadata: { ticker: existingHolding.ticker }
      });
      
      res.json({ success: deleted });
    } catch (error: unknown) {
      return res.status(400).json({ message: error instanceof Error ? error.message : "Unknown error" });
    }
  });

  // Retirement expenses routes
  app.get("/api/users/:userId/retirement-expenses", async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    const expenses = await storage.getRetirementExpenses(userId);
    return res.json(expenses);
  });

  app.post("/api/retirement-expenses", async (req: Request, res: Response) => {
    try {
      const expenseData = insertRetirementExpenseSchema.parse(req.body);
      const expense = await storage.createRetirementExpense(expenseData);
      return res.status(201).json(expense);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid expense data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to create retirement expense" });
    }
  });

  app.patch("/api/retirement-expenses/:id", async (req: Request, res: Response) => {
    const expenseId = parseInt(req.params.id);
    
    if (isNaN(expenseId)) {
      return res.status(400).json({ message: "Invalid expense ID" });
    }
    
    try {
      const expenseData = insertRetirementExpenseSchema.partial().parse(req.body);
      const updatedExpense = await storage.updateRetirementExpense(expenseId, expenseData);
      
      if (!updatedExpense) {
        return res.status(404).json({ message: "Retirement expense not found" });
      }
      
      return res.json(updatedExpense);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid expense data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to update retirement expense" });
    }
  });

  app.delete("/api/retirement-expenses/:id", async (req: Request, res: Response) => {
    const expenseId = parseInt(req.params.id);
    
    if (isNaN(expenseId)) {
      return res.status(400).json({ message: "Invalid expense ID" });
    }
    
    const success = await storage.deleteRetirementExpense(expenseId);
    
    if (!success) {
      return res.status(404).json({ message: "Retirement expense not found" });
    }
    
    return res.status(204).end();
  });

  // Activities routes
  app.get("/api/users/:userId/activities", async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    let limit: number | undefined = undefined;
    if (req.query.limit && typeof req.query.limit === 'string') {
      limit = parseInt(req.query.limit);
      if (isNaN(limit) || limit <= 0) {
        return res.status(400).json({ message: "Invalid limit parameter" });
      }
    }
    
    const activities = await storage.getActivities(userId, limit);
    return res.json(activities);
  });

  app.post("/api/activities", async (req: Request, res: Response) => {
    try {
      const activityData = insertActivitySchema.parse(req.body);
      const activity = await storage.createActivity(activityData);
      return res.status(201).json(activity);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid activity data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to create activity" });
    }
  });

  // Roth conversion plans routes
  app.get("/api/users/:userId/roth-conversion-plans", async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    const plans = await storage.getRothConversionPlans(userId);
    return res.json(plans);
  });

  app.get("/api/roth-conversion-plans/:id", async (req: Request, res: Response) => {
    const planId = parseInt(req.params.id);
    
    if (isNaN(planId)) {
      return res.status(400).json({ message: "Invalid plan ID" });
    }
    
    const plan = await storage.getRothConversionPlan(planId);
    
    if (!plan) {
      return res.status(404).json({ message: "Roth conversion plan not found" });
    }
    
    // Get scenarios for this plan
    let scenarios = await storage.getRothConversionScenarios(planId);
    
    // If no scenarios exist, generate sample scenarios
    if (scenarios.length === 0) {
      scenarios = await generateSampleScenarios(plan);
    }
    
    return res.json({ plan, scenarios });
  });

  app.post("/api/roth-conversion-plans", async (req: Request, res: Response) => {
    try {
      const planData = insertRothConversionPlanSchema.parse(req.body);
      const plan = await storage.createRothConversionPlan(planData);
      
      // Generate scenarios for the new plan
      const scenarios = await generateSampleScenarios(plan);
      
      // Create an activity for this plan creation
      await storage.createActivity({
        userId: planData.userId,
        activityType: "roth_conversion_plan_created",
        title: "Roth Conversion Plan Created",
        description: `Created Roth conversion plan: ${planData.planName}`,
        metadata: {
          planId: plan.id,
          conversionAmount: planData.conversionAmount,
          yearsToConvert: planData.yearsToConvert
        }
      });
      
      return res.status(201).json(plan);
    } catch (error: unknown) {
      console.error('Error creating Roth conversion plan:', error);
      if (error instanceof z.ZodError) {
        console.error('Validation errors:', error.errors);
        return res.status(400).json({ message: "Invalid plan data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to create Roth conversion plan" });
    }
  });

  app.post("/api/roth-conversion-plans/:id/scenarios", async (req: Request, res: Response) => {
    const planId = parseInt(req.params.id);
    
    if (isNaN(planId)) {
      return res.status(400).json({ message: "Invalid plan ID" });
    }
    
    try {
      // Delete existing scenarios for this plan
      await storage.deleteRothConversionScenarios(planId);
      
      // Insert new scenarios
      const scenarios = req.body.scenarios;
      if (!Array.isArray(scenarios)) {
        return res.status(400).json({ message: "Scenarios must be an array" });
      }
      
      const createdScenarios = [];
      for (const scenario of scenarios) {
        const scenarioData = {
          ...scenario,
          planId
        };
        const createdScenario = await storage.createRothConversionScenario(scenarioData);
        createdScenarios.push(createdScenario);
      }
      
      return res.status(201).json(createdScenarios);
    } catch (error: unknown) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid scenario data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to create scenarios" });
    }
  });

  app.patch("/api/roth-conversion-plans/:id", async (req: Request, res: Response) => {
    const planId = parseInt(req.params.id);
    
    if (isNaN(planId)) {
      return res.status(400).json({ message: "Invalid plan ID" });
    }
    
    try {
      const planData = insertRothConversionPlanSchema.partial().parse(req.body);
      const updatedPlan = await storage.updateRothConversionPlan(planId, planData);
      
      if (!updatedPlan) {
        return res.status(404).json({ message: "Roth conversion plan not found" });
      }
      
      // Create an activity for this plan update
      await storage.createActivity({
        userId: updatedPlan.userId,
        activityType: "roth_conversion_plan_updated",
        title: "Roth Conversion Plan Updated",
        description: `Updated Roth conversion plan: ${updatedPlan.planName}`,
        metadata: {
          planId: updatedPlan.id,
          conversionAmount: updatedPlan.conversionAmount,
          yearsToConvert: updatedPlan.yearsToConvert
        }
      });
      
      return res.json(updatedPlan);
    } catch (error: unknown) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid plan data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to update Roth conversion plan" });
    }
  });

  app.delete("/api/roth-conversion-plans/:id", async (req: Request, res: Response) => {
    const planId = parseInt(req.params.id);
    
    if (isNaN(planId)) {
      return res.status(400).json({ message: "Invalid plan ID" });
    }
    
    // Get the plan before deleting it to capture user info and plan details
    const plan = await storage.getRothConversionPlan(planId);
    if (!plan) {
      return res.status(404).json({ message: "Roth conversion plan not found" });
    }
    
    const success = await storage.deleteRothConversionPlan(planId);
    
    if (!success) {
      return res.status(404).json({ message: "Roth conversion plan not found" });
    }
    
    // Create an activity for this plan deletion
    await storage.createActivity({
      userId: plan.userId,
      activityType: "roth_conversion_plan_deleted",
      title: "Roth Conversion Plan Deleted",
      description: `Deleted Roth conversion plan: ${plan.planName}`,
      metadata: {
        planId: plan.id,
        conversionAmount: plan.conversionAmount,
        yearsToConvert: plan.yearsToConvert
      }
    });
    
    return res.status(204).end();
  });

  // Dashboard summary route
  app.get("/api/users/:userId/dashboard", async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    const user = await storage.getUser(userId);
    
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    
    // Get retirement goals
    const goals = await storage.getRetirementGoals(userId);
    
    // Get investment accounts
    const accounts = await storage.getInvestmentAccounts(userId);
    
    // Get asset allocations for all accounts
    const assetAllocations = [];
    for (const account of accounts) {
      const allocations = await storage.getAssetAllocations(account.id);
      assetAllocations.push(...allocations);
    }
    
    // Get security holdings for all accounts
    const securityHoldings = [];
    for (const account of accounts) {
      const holdings = await storage.getSecurityHoldings(account.id);
      securityHoldings.push(...holdings);
    }
    
    // Get retirement expenses
    const expenses = await storage.getRetirementExpenses(userId);
    
    // Get recent activities
    const activities = await storage.getActivities(userId, 3);
    
    // Get personalized recommendations
    const recommendations = await storage.getRecommendations(userId);
    
    // Get resources
    const resources = await storage.getResources();
    
    // Calculate total portfolio value
    const totalPortfolioValue = accounts.reduce((sum, account) => sum + Number(account.balance), 0);
    
    // Calculate retirement readiness score (simplified)
    const retirementReadinessScore = 78;
    
    // Calculate projected monthly income (simplified)
    const projectedMonthlyIncome = 5250;
    
    // Find the primary income goal if exists
    const primaryIncomeGoal = goals.find(goal => goal.category === "income") || null;
    
    // Calculate aggregate asset allocation
    const aggregateAssetAllocation = {
      stocks: 0,
      bonds: 0,
      realEstate: 0,
      cash: 0
    };
    
    // Sum the values for each asset category
    assetAllocations.forEach(allocation => {
      const value = Number(allocation.value);
      if (allocation.assetCategory === "stocks") {
        aggregateAssetAllocation.stocks += value;
      } else if (allocation.assetCategory === "bonds") {
        aggregateAssetAllocation.bonds += value;
      } else if (allocation.assetCategory === "real_estate") {
        aggregateAssetAllocation.realEstate += value;
      } else if (allocation.assetCategory === "cash") {
        aggregateAssetAllocation.cash += value;
      }
    });
    
    // Calculate total expenses
    const totalMonthlyExpenses = expenses.reduce(
      (sum, expense) => sum + Number(expense.estimatedMonthlyAmount), 
      0
    );
    
    // Calculate current savings rate (simplified)
    const currentSavingsRate = 15;
    
    // Return dashboard data
    return res.json({
      retirementReadiness: {
        score: retirementReadinessScore,
        targetRetirementAge: user.targetRetirementAge
      },
      monthlyIncome: {
        projected: projectedMonthlyIncome,
        goal: primaryIncomeGoal?.targetMonthlyIncome || 6000,
        percentOfCurrent: 87
      },
      savingsRate: {
        percentage: currentSavingsRate,
        monthlyAmount: 1250
      },
      portfolioAllocation: {
        total: totalPortfolioValue,
        categories: {
          stocks: {
            percentage: Math.round((aggregateAssetAllocation.stocks / totalPortfolioValue) * 100),
            value: aggregateAssetAllocation.stocks
          },
          bonds: {
            percentage: Math.round((aggregateAssetAllocation.bonds / totalPortfolioValue) * 100),
            value: aggregateAssetAllocation.bonds
          },
          realEstate: {
            percentage: Math.round((aggregateAssetAllocation.realEstate / totalPortfolioValue) * 100),
            value: aggregateAssetAllocation.realEstate
          },
          cash: {
            percentage: Math.round((aggregateAssetAllocation.cash / totalPortfolioValue) * 100),
            value: aggregateAssetAllocation.cash
          }
        }
      },
      incomeProjection: {
        portfolioIncome: 3800,
        socialSecurity: 1450,
        estimatedExpenses: totalMonthlyExpenses
      },
      recommendations: recommendations,
      resources: resources,
      recentActivities: activities,
      retirementGoals: goals // Add retirement goals to dashboard data
    });
  });

  // Multi-step form progress routes
  app.get("/api/users/:userId/multi-step-form-progress", async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    const progress = await storage.getMultiStepFormProgress(userId);
    return res.json(progress || null);
  });

  app.post("/api/users/:userId/multi-step-form-progress", async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    try {
      const progressData = insertMultiStepFormProgressSchema.parse({
        ...req.body,
        userId
      });
      
      // Check if progress already exists for this user
      const existingProgress = await storage.getMultiStepFormProgress(userId);
      
      if (existingProgress) {
        // Update existing progress
        const updatedProgress = await storage.updateMultiStepFormProgress(userId, req.body);
        return res.json(updatedProgress);
      } else {
        // Create new progress
        const newProgress = await storage.createMultiStepFormProgress(progressData);
        return res.status(201).json(newProgress);
      }
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid progress data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to save form progress" });
    }
  });

  app.patch("/api/users/:userId/multi-step-form-progress", async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    try {
      const progressData = insertMultiStepFormProgressSchema.partial().parse(req.body);
      const updatedProgress = await storage.updateMultiStepFormProgress(userId, progressData);
      
      if (!updatedProgress) {
        return res.status(404).json({ message: "Form progress not found" });
      }
      
      return res.json(updatedProgress);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid progress data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to update form progress" });
    }
  });

  app.delete("/api/users/:userId/multi-step-form-progress", async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    const success = await storage.deleteMultiStepFormProgress(userId);
    
    if (!success) {
      return res.status(404).json({ message: "Form progress not found" });
    }
    
    return res.status(204).end();
  });

  // Retirement plan routes
  app.get("/api/retirement-plans", requireAuth, async (req: Request, res: Response) => {
    const user = getCurrentUser(req);
    const plans = await storage.getRetirementPlans(user.id);
    return res.json(plans);
  });

  app.get("/api/retirement-plans/:id", requireAuth, async (req: Request, res: Response) => {
    const planId = parseInt(req.params.id);
    
    if (isNaN(planId)) {
      return res.status(400).json({ message: "Invalid plan ID" });
    }
    
    const plan = await storage.getRetirementPlan(planId);
    
    if (!plan) {
      return res.status(404).json({ message: "Retirement plan not found" });
    }
    
    return res.json(plan);
  });

  app.get("/api/retirement-plans/:id/details", requireAuth, async (req: Request, res: Response) => {
    const planId = parseInt(req.params.id);
    
    if (isNaN(planId)) {
      return res.status(400).json({ message: "Invalid plan ID" });
    }
    
    const plan = await storage.getRetirementPlan(planId);
    
    if (!plan) {
      return res.status(404).json({ message: "Retirement plan not found" });
    }
    
    // Get snapshots and milestones
    const snapshots = await storage.getAnnualSnapshots(planId);
    const milestones = await storage.getMilestones(planId);
    
    return res.json({
      ...plan,
      snapshots,
      milestones
    });
  });

  app.get("/api/retirement-plans/:id/year/:year", requireAuth, async (req: Request, res: Response) => {
    const planId = parseInt(req.params.id);
    const year = parseInt(req.params.year);
    
    if (isNaN(planId) || isNaN(year)) {
      return res.status(400).json({ message: "Invalid plan ID or year" });
    }
    
    const snapshot = await storage.getAnnualSnapshot(planId, year);
    
    if (!snapshot) {
      return res.status(404).json({ message: "Year data not found" });
    }
    
    // Get account balances and liabilities for this snapshot
    const accountBalances = await storage.getAccountBalances(snapshot.id);
    const liabilities = await storage.getLiabilities(snapshot.id);
    
    return res.json({
      snapshot,
      accountBalances,
      liabilities
    });
  });

  app.post("/api/retirement-plans", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = getCurrentUser(req);
      
      // Check 4 plan limit
      const existingPlans = await storage.getRetirementPlans(user.id);
      if (existingPlans.length >= 4) {
        return res.status(400).json({ message: "Maximum of 4 plans allowed per user" });
      }
      
      const planData = insertRetirementPlanSchema.parse({
        ...req.body,
        userId: user.id
      });
      
      const plan = await storage.createRetirementPlan(planData);
      
      // Generate financial projections for the new plan
      try {
        await generateRetirementPlan(plan);
      } catch (genError) {
        console.error(`❌ Failed to generate projections for plan ${plan.id}:`, genError);
        // Continue even if generation fails - user can regenerate later
      }
      
      // Create an activity for this plan creation
      await storage.createActivity({
        userId: user.id,
        activityType: "retirement_plan_created",
        title: "Retirement Plan Created",
        description: `Created retirement plan: ${planData.planName}`,
        metadata: {
          planId: plan.id,
          planType: planData.planType
        }
      });
      
      return res.status(201).json(plan);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid plan data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to create retirement plan" });
    }
  });

  app.patch("/api/retirement-plans/:id", requireAuth, async (req: Request, res: Response) => {
    const planId = parseInt(req.params.id);
    
    if (isNaN(planId)) {
      return res.status(400).json({ message: "Invalid plan ID" });
    }
    
    try {
      const planData = insertRetirementPlanSchema.partial().parse(req.body);
      const updatedPlan = await storage.updateRetirementPlan(planId, planData);
      
      if (!updatedPlan) {
        return res.status(404).json({ message: "Retirement plan not found" });
      }
      
      return res.json(updatedPlan);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid plan data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to update retirement plan" });
    }
  });

  app.delete("/api/retirement-plans/:id", requireAuth, async (req: Request, res: Response) => {
    const planId = parseInt(req.params.id);
    
    if (isNaN(planId)) {
      return res.status(400).json({ message: "Invalid plan ID" });
    }
    
    const success = await storage.deleteRetirementPlan(planId);
    
    if (!success) {
      return res.status(404).json({ message: "Retirement plan not found" });
    }
    
    return res.status(204).end();
  });

  // Milestones routes
  app.get("/api/milestones/standard", async (req: Request, res: Response) => {
    const milestones = await storage.getStandardMilestones();
    return res.json(milestones);
  });

  app.post("/api/milestones", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = getCurrentUser(req);
      const milestoneData = insertMilestoneSchema.parse({
        ...req.body,
        userId: req.body.milestoneType === 'personal' ? user.id : undefined
      });
      
      const milestone = await storage.createMilestone(milestoneData);
      return res.status(201).json(milestone);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid milestone data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to create milestone" });
    }
  });

  // Demo data seeding endpoint (development only)
  app.post("/api/seed-demo-data", async (req: Request, res: Response) => {
    try {
      // Create or find demo user
      let demoUser;
      try {
        demoUser = await storage.getUserByUsername("demo_user");
      } catch (e) {
        // User doesn't exist
      }

      if (!demoUser) {
        const hashedPassword = await bcrypt.hash("demo123", 10);
        
        demoUser = await storage.createUser({
          username: "demo_user",
          password: hashedPassword,
          firstName: "Demo",
          lastName: "User",
          email: "demo@example.com",
          currentAge: 30,
          targetRetirementAge: 65,
          currentLocation: "San Francisco, CA",
          maritalStatus: "single",
          dependents: 0,
          currentIncome: "85000",
          expectedFutureIncome: "120000",  
          desiredLifestyle: "comfortable",
          hasSpouse: false,
          totalMonthlyExpenses: "4500"
        });
      }

      // Check if plan exists
      const existingPlans = await storage.getRetirementPlans(demoUser.id);
      if (existingPlans.length > 0) {
        return res.json({ 
          message: "Demo data already exists", 
          user: demoUser.username,
          plans: existingPlans.length 
        });
      }

      // Create basic retirement plan
      const plan = await storage.createRetirementPlan({
        userId: demoUser.id,
        planName: "My Retirement Plan",
        planType: "comprehensive",
        startAge: 30,
        retirementAge: 65,
        endAge: 95,
        initialNetWorth: "250000",
        totalLifetimeTax: "750000",
        isActive: true
      });

      // Create a few sample snapshots
      const currentYear = new Date().getFullYear();
      const snapshots = [];
      
      for (let age = 30; age <= 95; age += 5) {
        const year = currentYear + (age - 30);
        const isRetired = age >= 65;
        const netWorth = 250000 + (age - 30) * 25000;
        
        const snapshot = await storage.createAnnualSnapshot({
          planId: plan.id,
          year,
          age,
          grossIncome: isRetired ? "50000" : "85000",
          netIncome: isRetired ? "45000" : "65000", 
          totalExpenses: "45000",
          totalAssets: netWorth.toString(),
          totalLiabilities: age < 50 ? "150000" : "0",
          netWorth: (netWorth - (age < 50 ? 150000 : 0)).toString(),
          taxesPaid: isRetired ? "5000" : "20000",
          cumulativeTax: ((age - 30) * 15000).toString()
        });
        
        snapshots.push(snapshot);
        
        // Add basic account balances
        await storage.createAccountBalance({
          snapshotId: snapshot.id,
          accountType: "401k",
          accountName: "Company 401(k)",
          balance: (netWorth * 0.4).toString(),
          contribution: isRetired ? "0" : "15000",
          withdrawal: isRetired ? "25000" : "0",
          growth: (netWorth * 0.04).toString()
        });

        await storage.createAccountBalance({
          snapshotId: snapshot.id,
          accountType: "roth_ira",
          accountName: "Roth IRA", 
          balance: (netWorth * 0.3).toString(),
          contribution: isRetired ? "0" : "6000",
          withdrawal: "0",
          growth: (netWorth * 0.03).toString()
        });

        await storage.createAccountBalance({
          snapshotId: snapshot.id,
          accountType: "brokerage",
          accountName: "Taxable Brokerage",
          balance: (netWorth * 0.2).toString(),
          contribution: "5000",
          withdrawal: isRetired ? "10000" : "0",
          growth: (netWorth * 0.02).toString()
        });

        await storage.createAccountBalance({
          snapshotId: snapshot.id,
          accountType: "savings", 
          accountName: "Emergency Fund",
          balance: (netWorth * 0.1).toString(),
          contribution: "2000",
          withdrawal: "0",
          growth: (netWorth * 0.01).toString()
        });
      }

      // Create sample milestones
      await storage.createMilestone({
        planId: plan.id,
        userId: demoUser.id,
        milestoneType: "personal",
        title: "Pay Off Mortgage",
        description: "Complete mortgage payments",
        targetYear: currentYear + 20,
        targetAge: 50,
        category: "housing",
        color: "#8b5cf6",
        icon: "home"
      });

      await storage.createMilestone({
        planId: null,
        userId: null,
        milestoneType: "standard", 
        title: "Medicare Eligibility",
        description: "Eligible for Medicare benefits",
        targetYear: null,
        targetAge: 65,
        category: "healthcare",
        color: "#ef4444", 
        icon: "shield"
      });

      return res.json({
        message: "Demo data created successfully!",
        user: demoUser.username,
        planId: plan.id,
        snapshots: snapshots.length
      });

    } catch (error) {
      console.error("Seeding error:", error);
      return res.status(500).json({ 
        message: "Failed to seed demo data", 
        error: error instanceof Error ? error.message : "Unknown error" 
      });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
